// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

// Looking for ways to speed up your queries, or scale easily with your serverless or edge functions?
// Try Prisma Accelerate: https://pris.ly/cli/accelerate-init

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model Permission {
  id              String           @id @default(uuid())
  name            String           @unique
  description     String?
  userPermissions UserPermission[]
  rolePermissions RolePermission[]
}

model UserPermission {
  id          String     @id @default(uuid())
  userId      String
  user        User       @relation("UserToUserPermission", fields: [userId], references: [id])
  permission  String
  permissionRef Permission @relation(fields: [permission], references: [name])
  grantedBy   String
  grantedAt   DateTime   @default(now())
  tenant      Tenant     @relation(fields: [tenantId], references: [id])
  tenantId    String
  
  @@unique([userId, permission, tenantId])
}

model Product {
  id           String      @id @default(uuid())
  name         String
  sku          String
  price        Float
  description  String?
  stock        Int         @default(0)
  tenantId     String
  tenant       Tenant      @relation(fields: [tenantId], references: [id])
  inventory    Inventory[]
  createdAt    DateTime    @default(now())
  updatedAt    DateTime    @updatedAt
  saleItems    SaleItem[]
  customFields Json?
  branchId     String?
  branch       Branch?     @relation(fields: [branchId], references: [id])

  @@index([tenantId])
  @@index([branchId])
}

model Inventory {
  id        String   @id @default(uuid())
  productId String
  product   Product  @relation(fields: [productId], references: [id])
  quantity  Int
  tenantId  String
  tenant    Tenant   @relation(fields: [tenantId], references: [id])
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([tenantId])
  @@index([productId])
}

model Sale {
  id                 String            @id @default(uuid())
  tenantId           String
  tenant             Tenant            @relation(fields: [tenantId], references: [id])
  userId             String
  user               User              @relation(fields: [userId], references: [id])
  total              Float
  paymentType        String
  items              SaleItem[]
  createdAt          DateTime          @default(now())
  customerName       String?
  customerPhone      String?
  mpesaTransactionId String?           @unique
  mpesaTransactions  MpesaTransaction[]
  idempotencyKey     String?
  vatAmount          Float? // KRA VAT amount
  branchId           String?
  branch             Branch?           @relation(fields: [branchId], references: [id])

  @@unique([idempotencyKey, userId])
  @@index([tenantId])
  @@index([userId])
  @@index([branchId])
}

model SaleItem {
  id        String  @id @default(uuid())
  saleId    String
  sale      Sale    @relation(fields: [saleId], references: [id])
  productId String
  product   Product @relation(fields: [productId], references: [id])
  quantity  Int
  price     Float

  @@index([productId])
}

model Module {
  id          String         @id @default(uuid())
  name        String         @unique
  description String?
  tenants     TenantModule[]
}

model TenantModule {
  id       String  @id @default(uuid())
  tenantId String
  moduleId String
  enabled  Boolean @default(true)
  tenant   Tenant  @relation(fields: [tenantId], references: [id])
  module   Module  @relation(fields: [moduleId], references: [id])
}

model MpesaTransaction {
  id              String   @id @default(uuid())
  transactionId   String
  transactionType String
  amount          Float
  phoneNumber     String
  accountReference String?
  status          String
  resultCode      String?
  resultDesc      String?
  merchantRequestID String?
  checkoutRequestID String?
  responseCode     String?
  responseDescription String?
  customerMessage  String?
  requestData      Json?
  responseData     Json?
  metadata         Json?
  tenant           Tenant  @relation(fields: [tenantId], references: [id])
  tenantId         String
  user             User?   @relation(fields: [userId], references: [id])
  userId           String?
  sale             Sale?   @relation(fields: [saleId], references: [id])
  saleId           String? @unique
  
  @@unique([saleId])
  @@unique([transactionId])
}

model AuditLog {
  id        String   @id @default(uuid())
  userId    String?
  user      User?    @relation(fields: [userId], references: [id])
  action    String
  details   Json?
  ip        String?
  createdAt DateTime @default(now())
}

model Role {
  id              String           @id @default(uuid())
  name            String           @unique
  description     String?
  rolePermissions RolePermission[]
  userRoles       UserRole[]
  userBranchRoles UserBranchRole[]
  tenant          Tenant?          @relation(fields: [tenantId], references: [id])
  tenantId        String?
  
  @@unique([name, tenantId])
}

model RolePermission {
  id           String     @id @default(uuid())
  roleId       String
  permissionId String
  role         Role       @relation(fields: [roleId], references: [id])
  permission   Permission @relation(fields: [permissionId], references: [id])
}

model UserRole {
  id       String @id @default(uuid())
  user     User   @relation(fields: [userId], references: [id])
  userId   String
  role     Role   @relation(fields: [roleId], references: [id])
  roleId   String
  tenant   Tenant @relation(fields: [tenantId], references: [id])
  tenantId String
}

model Plan {
  id              String          @id @default(uuid())
  name            String          @unique
  description     String
  price           Float
  interval        String          // 'month' or 'year'
  isActive        Boolean         @default(true)
  maxUsers        Int?
  maxProducts     Int?
  maxSalesPerMonth Int?
  features        PlanFeatureOnPlan[]
  subscriptions   Subscription[]
  createdAt       DateTime        @default(now())
  updatedAt       DateTime        @updatedAt
}

model PlanFeature {
  id              String          @id @default(uuid())
  featureKey      String          @unique
  featureName     String
  featureDescription String?
  isEnabled       Boolean         @default(true)
  plans           PlanFeatureOnPlan[]
  createdAt       DateTime        @default(now())
  updatedAt       DateTime        @updatedAt
}

model PlanFeatureOnPlan {
  planId          String
  plan            Plan            @relation(fields: [planId], references: [id], onDelete: Cascade)
  featureId       String
  feature         PlanFeature     @relation(fields: [featureId], references: [id], onDelete: Cascade)
  createdAt       DateTime        @default(now())
  updatedAt       DateTime        @updatedAt

  @@id([planId, featureId])
}

model Subscription {
  id                  String          @id @default(uuid())
  tenantId            String?
  tenant              Tenant?         @relation("TenantSubscriptions", fields: [tenantId], references: [id])
  userId              String?
  user                User?           @relation("UserSubscriptions", fields: [userId], references: [id])
  planId              String
  plan                Plan            @relation(fields: [planId], references: [id])
  status              String          // 'active', 'canceled', 'past_due', 'unpaid'
  currentPeriodStart  DateTime
  currentPeriodEnd    DateTime
  cancelAtPeriodEnd   Boolean         @default(false)
  stripeCustomerId    String?
  stripeSubscriptionId String?
  stripePriceId       String?
  quantity           Int             @default(1)
  invoices           Invoice[]
  createdAt          DateTime        @default(now())
  updatedAt          DateTime        @updatedAt

  @@index([tenantId])
  @@index([userId])
  @@index([stripeCustomerId])
  @@index([stripeSubscriptionId])
}

model Invoice {
  id              String        @id @default(uuid())
  number          String        @unique
  amount          Float
  status          String        // 'draft', 'open', 'paid', 'void', 'uncollectible'
  dueDate         DateTime?
  paidAt          DateTime?
  subscriptionId  String?
  subscription    Subscription? @relation(fields: [subscriptionId], references: [id])
  tenantId        String
  tenant          Tenant        @relation(fields: [tenantId], references: [id])
  createdAt       DateTime      @default(now())
  updatedAt       DateTime      @updatedAt

  @@index([tenantId])
  @@index([subscriptionId])
}

model Payment {
  id                    String    @id @default(uuid())
  tenantId              String
  tenant                Tenant    @relation(fields: [tenantId], references: [id])
  stripePaymentIntentId String?   @unique
  amount                Float
  currency              String    @default("USD")
  status                String // pending, completed, failed, canceled
  description           String?
  metadata              Json?
  completedAt           DateTime?
  refundedAt            DateTime?
  refundAmount          Float?
  refundReason          String?
  createdAt             DateTime  @default(now())
  updatedAt             DateTime  @updatedAt

  @@index([tenantId])
  @@index([status])
  @@index([createdAt])
}

model PaymentMethod {
  id        String   @id @default(uuid())
  tenantId  String
  tenant    Tenant   @relation(fields: [tenantId], references: [id])
  type      String // card, bank_account, mpesa
  last4     String?
  brand     String? // visa, mastercard, etc.
  expMonth  Int?
  expYear   Int?
  isDefault Boolean  @default(false)
  metadata  Json?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([tenantId])
}

model Branch {
  id        String           @id @default(uuid())
  name      String
  address   String?
  tenantId  String
  tenant    Tenant           @relation(fields: [tenantId], references: [id])
  users     UserBranchRole[]
  products  Product[] // If you want branch-specific products/inventory
  sales     Sale[] // If you want branch-specific sales
  createdAt DateTime         @default(now())
  updatedAt DateTime         @updatedAt

  @@index([tenantId])
}

model UserBranchRole {
  id        String   @id @default(uuid())
  userId    String
  user      User     @relation(fields: [userId], references: [id])
  branchId  String
  branch    Branch   @relation(fields: [branchId], references: [id])
  roleId    String
  role      Role     @relation(fields: [roleId], references: [id])
  tenant    Tenant   @relation(fields: [tenantId], references: [id])
  tenantId  String
  
  @@unique([userId, branchId, roleId])
}

model SystemConfiguration {
  id          String   @id @default(uuid())
  key         String   @unique
  value       String
  description String?
  category    String // 'security', 'api', 'external_services', 'email', 'general'
  isEncrypted Boolean  @default(false)
  isPublic    Boolean  @default(false) // Whether this can be exposed to frontend
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  @@index([category])
  @@index([key])
}

model TenantConfiguration {
  id          String   @id @default(uuid())
  tenantId    String
  key         String
  value       String
  description String?
  category    String // 'stripe', 'payment', 'billing', 'general'
  isEncrypted Boolean  @default(false)
  isPublic    Boolean  @default(false) // Whether this can be exposed to frontend
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  tenant      Tenant   @relation(fields: [tenantId], references: [id], onDelete: Cascade)

  @@unique([tenantId, key])
  @@index([tenantId])
  @@index([category])
  @@index([key])
}

model Tenant {
  id                  String              @id @default(uuid())
  name                String
  businessType        String
  contactEmail        String
  contactPhone        String?
  // Enhanced business information
  businessCategory    String?
  businessSubcategory String?
  primaryProducts     Json?
  secondaryProducts   Json?
  businessDescription String?
  // Location information
  address             String?
  city                String?
  state               String?
  country             String?
  postalCode          String?
  latitude            Float?
  longitude           Float?
  // Business details
  foundedYear         Int?
  employeeCount       String?
  annualRevenue       String?
  businessHours       Json?
  website             String?
  socialMedia         Json?
  // Legal and compliance
  kraPin              String?
  vatNumber           String?
  etimsQrUrl          String?
  businessLicense     String?
  taxId               String?
  // Financial settings
  currency            String?               @default("KES")
  timezone            String?               @default("Africa/Nairobi")
  invoiceFooter       String?
  credits             Float?                @default(0) // Account balance for one-time payments
  logoUrl             String?
  loginLogoUrl        String?               // URL for login page logo
  favicon             String?
  receiptLogo         String?
  watermark           String?
  dashboardLogoUrl    String?
  emailLogoUrl        String?
  mobileLogoUrl       String?
  logoSettings        Json?
  // Enterprise features
  primaryColor        String?
  secondaryColor      String?
  customDomain        String?
  whiteLabel          Boolean               @default(false)
  apiKey              String?
  webhookUrl          String?
  rateLimit           Int?
  customIntegrations  Boolean               @default(false)
  ssoEnabled          Boolean               @default(false)
  auditLogsEnabled    Boolean               @default(false)  // Renamed to avoid conflict
  backupRestore       Boolean               @default(false)
  stripeCustomerId    String?               @unique
  // Timestamps
  createdAt           DateTime              @default(now())
  updatedAt           DateTime              @updatedAt
  // Relations
  users               User[]
  products            Product[]
  inventory           Inventory[]
  sales               Sale[]
  modules             TenantModule[]
  subscriptions       Subscription[]   @relation("TenantSubscriptions")
  invoices            Invoice[]
  payments            Payment[]
  paymentMethods      PaymentMethod[]
  branches            Branch[]
  configurations      TenantConfiguration[]
  userRoles           UserRole[]
  userBranchRoles     UserBranchRole[]
  mpesaTransactions   MpesaTransaction[]
  notifications       Notification[]
  userPermissions     UserPermission[]
  roles               Role[]
}

model User {
  id                      String             @id @default(uuid())
  email                   String             @unique
  password                String
  name                    String
  isSuperadmin            Boolean            @default(false)
  resetPasswordToken      String?
  resetPasswordExpires    DateTime?
  notificationPreferences Json?
  language                String?
  region                  String?
  createdAt               DateTime           @default(now())
  updatedAt               DateTime           @updatedAt
  // Relations
  userRoles               UserRole[]
  userPermissions         UserPermission[] @relation("UserToUserPermission")
  permissions             UserPermission[] @relation("UserPermissions")
  sales                   Sale[]
  mpesaTransactions       MpesaTransaction[]
  auditLogs               AuditLog[]
  userBranchRoles         UserBranchRole[]
  tenant                  Tenant?          @relation(fields: [tenantId], references: [id])
  tenantId                String?
  subscriptions           Subscription[]   @relation("UserSubscriptions")
  notifications           Notification[]   @relation("UserNotifications")

  @@index([email])
  @@index([resetPasswordToken])
}

model Notification {
  id          String   @id @default(uuid())
  type        String   // e.g., 'system', 'payment', 'subscription'
  title       String
  message     String
  isRead      Boolean  @default(false)
  data        Json?    // Additional data for the notification
  tenant      Tenant   @relation(fields: [tenantId], references: [id])
  tenantId    String
  user        User?    @relation("UserNotifications", fields: [userId], references: [id])
  userId      String?
  createdAt   DateTime @default(now())
  readAt      DateTime?
}
